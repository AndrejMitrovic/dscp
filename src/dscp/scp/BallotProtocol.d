// Copyright 2014 Stellar Development Foundation and contributors. Licensed
// under the Apache License, Version 2.0. See the COPYING file at the root
// of this distribution or at http://www.apache.org/licenses/LICENSE-2.0

module dscp.scp.BallotProtocol;

import dscp.scp.LocalNode;
import dscp.scp.SCP;
import dscp.scp.SCPDriver;
import dscp.scp.Slot;
import dscp.scp.QuorumSetUtils;
import dscp.util.Log;
import dscp.xdr.Stellar_SCP;
import dscp.xdr.Stellar_types;

import std.range;

import core.stdc.stdint;
import core.time;

// used to filter statements
alias StatementPredicate = bool delegate (ref const(SCPStatement));

// max number of transitions that can occur from processing one message
private enum MAX_ADVANCE_SLOT_RECURSION = 50;

// An interval is [low,high] represented as a pair
struct Interval
{
    uint32 first;
    uint32 second;
}

/**
 * The Slot object is in charge of maintaining the state of the SCP protocol
 * for a given slot index.
 */
class BallotProtocol
{
    private Slot mSlot;
    private bool mHeardFromQuorum;

    // state tracking members
    private enum SCPPhase
    {
        SCP_PHASE_PREPARE,
        SCP_PHASE_CONFIRM,
        SCP_PHASE_EXTERNALIZE,
    }

    // todo: this was unique_ptr, keeping refcount..
    private SCPBallot* mCurrentBallot;      // b
    private SCPBallot* mPrepared;           // p
    private SCPBallot* mPreparedPrime;      // p'
    private SCPBallot* mHighBallot;         // h
    private SCPBallot* mCommit;             // c
    private SCPEnvelope[NodeID] mLatestEnvelopes; // M
    private SCPPhase mPhase = SCPPhase.SCP_PHASE_PREPARE;  // Phi
    // todo: this was unique_ptr
    private Value mValueOverride;           // z

    private int mCurrentMessageLevel = 0; // number of messages triggered in one run

    // todo: this was shared_ptr
    private SCPEnvelope* mLastEnvelope; // last envelope generated by this node
    private SCPEnvelope* mLastEnvelopeEmit; // last envelope emitted by this node

    public this (Slot slot)
    {
        mSlot = slot;
    }

    // Process a newly received envelope for this slot and update the state of
    // the slot accordingly.
    // self: set to true when node feeds its own statements in order to
    // trigger more potential state changes
    public SCP.EnvelopeState processEnvelope (ref const(SCPEnvelope) envelope,
        bool self)
    {
        assert(envelope.statement.slotIndex == mSlot.getSlotIndex());

        if (!isStatementSane(envelope.statement, self))
        {
            if (self)
                log.info("not sane statement from self, skipping   e: ",
                    mSlot.getSCP().envToStr(envelope));

            return SCP.EnvelopeState.INVALID;
        }

        if (!isNewerStatement(envelope.statement.nodeID, envelope.statement))
        {
            if (self)
                log.error("stale statement from self, skipping   e: ",
                    mSlot.getSCP().envToStr(envelope));
            else
                log.trace("stale statement, skipping  i: ", mSlot.getSlotIndex());

            return SCP.EnvelopeState.INVALID;
        }

        auto validationRes = validateValues(envelope.statement);
        if (validationRes == ValidationLevel.kInvalidValue)
        {
            // If the value is not valid, we just ignore it.
            if (self)
                log.error("invalid value from self, skipping   e: ",
                    mSlot.getSCP().envToStr(envelope));
            else
                log.trace("invalid value  i: ", mSlot.getSlotIndex());

            return SCP.EnvelopeState.INVALID;
        }

        if (mPhase == SCPPhase.SCP_PHASE_EXTERNALIZE)
        {
            // note: this handles also our own messages
            // in particular our final EXTERNALIZE message
            if (mCommit.value == getWorkingBallot(envelope.statement).value)
            {
                // note: the slot is not advanced, because externalize is final
                recordEnvelope(envelope);
                return SCP.EnvelopeState.VALID;
            }

            if (self)
                log.error("externalize statement with invalid value " ~
                    "from self, skipping   e: ",
                    mSlot.getSCP().envToStr(envelope));

            return SCP.EnvelopeState.INVALID;
        }
        else
        {
            if (validationRes == ValidationLevel.kMaybeValidValue)
                mSlot.setFullyValidated(false);

            recordEnvelope(envelope);
            this.advanceSlot(envelope.statement);
            return SCP.EnvelopeState.VALID;
        }
    }

    public void ballotProtocolTimerExpired ()
    {
        abandonBallot(0);
    }

    // abandon's current ballot, move to a new ballot
    // at counter `n` (or, if n == 0, increment current counter)
    public bool abandonBallot (uint32 n)
    {
        //log.trace("BallotProtocol.abandonBallot";
        Value v = mSlot.getLatestCompositeCandidate().dup;
        if (v.empty())
        {
            if (mCurrentBallot)
                v = mCurrentBallot.value;
        }

        if (!v.empty())
        {
            if (n == 0)
                return this.bumpState(v, true);
            else
                return this.bumpState(v, n);  // overload
        }

        return false;
    }

    // bumps the ballot based on the local state and the value passed in:
    // in prepare phase, attempts to take value
    // otherwise, no-ops
    // force: when true, always bumps the value, otherwise only bumps
    // the state if no value was prepared
    public bool bumpState (ref const(Value) value, bool force)
    {
        if (!force && mCurrentBallot)
            return false;

        uint32 n = mCurrentBallot ? (mCurrentBallot.counter + 1) : 1;
        return this.bumpState(value, n);
    }

    // flavor that takes the actual desired counter value
    public bool bumpState (ref const(Value) value, uint32 n)
    {
        if (mPhase != SCPPhase.SCP_PHASE_PREPARE &&
            mPhase != SCPPhase.SCP_PHASE_CONFIRM)
            return false;

        SCPBallot newb;
        newb.counter = n;

        if (mValueOverride !is null)
        {
            // we use the value that we saw confirmed prepared
            // or that we at least voted to commit to
            newb.value = mValueOverride;
        }
        else
        {
            newb.value = value.dup;
        }

        //if (Logging.logTrace("SCP"))
        //    log.trace("BallotProtocol.bumpState"
        //                       << " i: " << mSlot.getSlotIndex()
        //                       << " v: " << mSlot.getSCP().ballotToStr(newb);

        if (!updateCurrentValue(newb))
            return false;

        this.emitCurrentStateStatement();
        checkHeardFromQuorum();
        return true;
    }

    // ** status methods

    // helper function to retrieve b for PREPARE, P for CONFIRM or
    // c for EXTERNALIZE messages
    public static SCPBallot getWorkingBallot (ref const(SCPStatement) st)
    {
        final switch (st.pledges.type)
        {
            case SCPStatementType.SCP_ST_PREPARE:
                return st.pledges.prepare_.ballot;

            case SCPStatementType.SCP_ST_CONFIRM:
            {
                const con = &st.pledges.confirm_;
                return SCPBallot(con.nCommit, con.ballot.value.dup);
            }

            case SCPStatementType.SCP_ST_EXTERNALIZE:
                return st.pledges.externalize_.commit;

            case SCPStatementType.SCP_ST_NOMINATE:
                assert(0);  // unexpected
        }
    }

    /// used externally by client code
    public const(SCPEnvelope)* getLastMessageSend () const
    {
        return mLastEnvelopeEmit.get();
    }

    /// Only used during boot-up if we want to load old SCP state
    public void setStateFromEnvelope (ref const(SCPEnvelope) e)
    {
        if (mCurrentBallot !is null)
            assert(0, "Cannot set state after starting ballot protocol");

        recordEnvelope(e);

        mLastEnvelope = new SCPEnvelope;
        *mLastEnvelope = e;
        mLastEnvelopeEmit = mLastEnvelope;

        const pl = &e.statement.pledges;

        final switch (pl.type)
        {
            case SCPStatementType.SCP_ST_PREPARE:
            {
                const prep = &pl.prepare_;
                const b = &prep.ballot;
                bumpToBallot(*b, true);

                if (prep.prepared)
                {
                    mPrepared = new SCPBallot;
                    *mPrepared = *cast(SCPBallot*)prep.prepared;
                }

                if (prep.preparedPrime)
                {
                    mPreparedPrime = new SCPBallot;
                    *mPreparedPrime = *cast(SCPBallot*)prep.preparedPrime;
                }

                if (prep.nH)
                {
                    mHighBallot = new SCPBallot;
                    *mHighBallot = SCPBallot(prep.nH, b.value.dup);
                }

                if (prep.nC)
                {
                    mCommit = new SCPBallot;
                    *mCommit = SCPBallot(prep.nC, b.value.dup);
                }

                mPhase = SCPPhase.SCP_PHASE_PREPARE;
                break;
            }

            case SCPStatementType.SCP_ST_CONFIRM:
            {
                const c = &pl.confirm_;
                const v = &c.ballot.value;
                bumpToBallot(c.ballot, true);
                mPrepared = new SCPBallot;
                *mPrepared = SCPBallot(c.nPrepared, (*v).dup);
                mHighBallot = new SCPBallot;
                *mHighBallot = SCPBallot(c.nH, (*v).dup);
                mCommit = new SCPBallot;
                *mCommit = SCPBallot(c.nCommit, (*v).dup);
                mPhase = SCPPhase.SCP_PHASE_CONFIRM;
                break;
            }

            case SCPStatementType.SCP_ST_EXTERNALIZE:
            {
                const ext = &pl.externalize_;
                const v = &ext.commit.value;
                auto bump_ballot = SCPBallot(uint.max, (*v).dup);
                bumpToBallot(bump_ballot, true);
                mPrepared = new SCPBallot;
                *mPrepared = SCPBallot(uint.max, (*v).dup);
                mHighBallot = new SCPBallot;
                *mHighBallot = SCPBallot(ext.nH, (*v).dup);
                mCommit = new SCPBallot;
                *mCommit = *cast(SCPBallot*)&ext.commit;
                mPhase = SCPPhase.SCP_PHASE_EXTERNALIZE;
                break;
            }

            case SCPStatementType.SCP_ST_NOMINATE:
                assert(0);  // unexpected
        }
    }

    /// only used by external code
    public SCPEnvelope[] getCurrentState () const
    {
        SCPEnvelope[] res;
        res.reserve(mLatestEnvelopes.length);
        foreach (node_id, env; mLatestEnvelopes)
        {
            // only return messages for self if the slot is fully validated
            if (node_id != mSlot.getSCP().getLocalNodeID() ||
                mSlot.isFullyValidated())
                res ~= env;
        }

        return res;
    }

    // returns the latest message from a node
    // or null if not found
    public const(SCPEnvelope)* getLatestMessage (ref const(NodeID) id) const
    {
        return id in mLatestEnvelopes;
    }

    /// returns messages that contributed to externalizing the given slot index
    /// (or null if the slot didn't externalize)
    public SCPEnvelope[] getExternalizingState () const
    {
        if (mPhase != SCPPhase.SCP_PHASE_EXTERNALIZE)
            return null;

        SCPEnvelope[] res;
        res.reserve(mLatestEnvelopes.length);
        foreach (node_id, env; mLatestEnvelopes)
        {
            if (node_id != mSlot.getSCP().getLocalNodeID())
            {
                // good approximation: statements with the value that
                // externalized
                // we could filter more using mConfirmedPrepared as well
                auto work_ballot = getWorkingBallot(env.statement);
                if (areBallotsCompatible(work_ballot, *mCommit))
                    res ~= env;
            }
            else if (mSlot.isFullyValidated())
            {
                // only return messages for self if the slot is fully validated
                res ~= env;
            }
        }

        return res;
    }

    // attempts to make progress using the latest statement as a hint
    // calls into the various attempt* methods, emits message
    // to make progress
    private void advanceSlot (ref const(SCPStatement) hint)
    {
        mCurrentMessageLevel++;
        //if (Logging.logTrace("SCP"))
        //    log.trace("BallotProtocol.advanceSlot "
        //                       << mCurrentMessageLevel << " " << getLocalState();

        // TODO: verify the safety of this, it seems like it could cause a crash
        if (mCurrentMessageLevel >= MAX_ADVANCE_SLOT_RECURSION)
            assert(0, "maximum number of transitions reached in advanceSlot");

        // attempt* methods will queue up messages, causing advanceSlot to be
        // called recursively

        // done in order so that we follow the steps from the white paper in
        // order
        // allowing the state to be updated properly

        bool didWork;
        didWork |= attemptPreparedAccept(hint);
        didWork |= attemptPreparedConfirmed(hint);
        didWork |= attemptAcceptCommit(hint);
        didWork |= attemptConfirmCommit(hint);

        // only bump after we're done with everything else
        if (mCurrentMessageLevel == 1)
        {
            bool didBump = false;
            do
            {
                // attemptBump may invoke advanceSlot recursively
                didBump = attemptBump();
                didWork = didBump || didWork;
            } while (didBump);

            checkHeardFromQuorum();
        }

        //if (Logging.logTrace("SCP"))
        //    log.trace("BallotProtocol.advanceSlot "
        //                       << mCurrentMessageLevel << " - exiting "
        //                       << getLocalState();

        --mCurrentMessageLevel;

        if (didWork)
            sendLatestEnvelope();
    }

    // returns true if all values in statement are valid
    private ValidationLevel validateValues(ref const(SCPStatement) st)
    {
        set!Value values;
        final switch (st.pledges.type)
        {
            case SCPStatementType.SCP_ST_PREPARE:
            {
                const prep = &st.pledges.prepare_;
                const b = &prep.ballot;
                if (b.counter != 0)
                    values.insert(prep.ballot.value);

                if (prep.prepared)
                    values.insert(prep.prepared.value);

                break;
            }

            case SCPStatementType.SCP_ST_CONFIRM:
                values.insert(st.pledges.confirm_.ballot.value);
                break;

            case SCPStatementType.SCP_ST_EXTERNALIZE:
                values.insert(st.pledges.externalize_.commit.value);
                break;

            case SCPStatementType.SCP_ST_NOMINATE:
                assert(0);
        }

        ValidationLevel res = ValidationLevel.kFullyValidatedValue;
        foreach (v; values)
        {
            auto tr = mSlot.getSCPDriver().validateValue(
                mSlot.getSlotIndex(), v, false);
            if (tr != ValidationLevel.kFullyValidatedValue)
            {
                if (tr == ValidationLevel.kInvalidValue)
                    res = ValidationLevel.kInvalidValue;
                else
                    res = ValidationLevel.kMaybeValidValue;
            }
        }

        return res;
    }

    // send latest envelope if needed
    private void sendLatestEnvelope()
    {
        // emit current envelope if needed
        if (mCurrentMessageLevel == 0 && mLastEnvelope && mSlot.isFullyValidated())
        {
            if (!mLastEnvelopeEmit || mLastEnvelope != mLastEnvelopeEmit)
            {
                mLastEnvelopeEmit = mLastEnvelope;
                mSlot.getSCPDriver().emitEnvelope(*mLastEnvelopeEmit);
            }
        }
    }

    // `attempt*` methods are called by `advanceSlot` internally call the
    //  the `set*` methods.
    //   * check if the specified state for the current slot has been
    //     reached or not.
    //   * idempotent
    //  input: latest statement received (used as a hint to reduce the
    //  space to explore)
    //  output: returns true if the state was updated

    // `set*` methods progress the slot to the specified state
    //  input: state specific
    //  output: returns true if the state was updated.

    // step 1 and 5 from the SCP paper
    private bool attemptPreparedAccept(ref const(SCPStatement) hint)
    {
        if (mPhase != SCPPhase.SCP_PHASE_PREPARE &&
            mPhase != SCPPhase.SCP_PHASE_CONFIRM)
            return false;

        auto candidates = getPrepareCandidates(hint);

        // todo: set needs to be sorted so we can iterate over it from highest ballot
        // to lowest ballot
        // see if we can accept any of the candidates, starting with the highest
        foreach (cur; candidates[].retro)
        {
            const(SCPBallot) ballot = cur;

            if (mPhase == SCPPhase.SCP_PHASE_CONFIRM)
            {
                // only consider the ballot if it may help us increase
                // p (note: at this point, p ~ c)
                if (!areBallotsLessAndCompatible(*mPrepared, ballot))
                    continue;

                assert(areBallotsCompatible(*mCommit, ballot));
            }

            // if we already prepared this ballot, don't bother checking again

            // if ballot <= p' ballot is neither a candidate for p nor p'
            if (mPreparedPrime && compareBallots(ballot, *mPreparedPrime) <= 0)
                continue;

            if (mPrepared)
            {
                // if ballot is already covered by p, skip
                if (areBallotsLessAndCompatible(ballot, *mPrepared))
                    continue;

                // otherwise, there is a chance it increases p'
            }

            bool accepted = federatedAccept(
                // checks if any node is voting for this ballot
                (ref const(SCPStatement) st) {
                    bool res;

                    final switch (st.pledges.type)
                    {
                        case SCPStatementType.SCP_ST_PREPARE:
                        {
                            const p = &st.pledges.prepare_;
                            res = areBallotsLessAndCompatible(ballot, p.ballot);
                            break;
                        }

                        case SCPStatementType.SCP_ST_CONFIRM:
                        {
                            const c = &st.pledges.confirm_;
                            res = areBallotsCompatible(ballot, c.ballot);
                            break;
                        }

                        case SCPStatementType.SCP_ST_EXTERNALIZE:
                        {
                            const e = &st.pledges.externalize_;
                            res = areBallotsCompatible(ballot, e.commit);
                            break;
                        }

                        case SCPStatementType.SCP_ST_NOMINATE:
                            assert(0);
                    }

                    return res;
                },
                (ref const(SCPStatement) st) => hasPreparedBallot(ballot, st));

            if (accepted)
                return setPreparedAccept(ballot);
        }

        return false;
    }

    // prepared: ballot that should be prepared
    private bool setPreparedAccept (ref const(SCPBallot) ballot)
    {
        //if (Logging.logTrace("SCP"))
        //    log.trace("BallotProtocol.setPreparedAccept"
        //                       << " i: " << mSlot.getSlotIndex()
        //                       << " b: " << mSlot.getSCP().ballotToStr(ballot);

        // update our state
        bool didWork = setPrepared(ballot);

        // check if we also need to clear 'c'
        if (mCommit && mHighBallot)
        {
            if ((mPrepared &&
                 areBallotsLessAndIncompatible(*mHighBallot, *mPrepared)) ||
                (mPreparedPrime &&
                 areBallotsLessAndIncompatible(*mHighBallot, *mPreparedPrime)))
            {
                assert(mPhase == SCPPhase.SCP_PHASE_PREPARE);
                mCommit = null;
                didWork = true;
            }
        }

        if (didWork)
        {
            mSlot.getSCPDriver().acceptedBallotPrepared(mSlot.getSlotIndex(),
                ballot);
            this.emitCurrentStateStatement();
        }

        return didWork;
    }

    // step 2+3+8 from the SCP paper
    // ballot is the candidate to record as 'confirmed prepared'
    private bool attemptPreparedConfirmed (ref const(SCPStatement) hint)
    {
        if (mPhase != SCPPhase.SCP_PHASE_PREPARE)
            return false;

        // check if we could accept this ballot as prepared
        if (!mPrepared)
            return false;

        auto candidates = getPrepareCandidates(hint);

        // see if we can accept any of the candidates, starting with the highest
        SCPBallot newH;
        bool newHfound = false;

        auto range = candidates[].retro;
        while (!range.empty)
        {
            auto cur = range.front();
            range.popFront();
            SCPBallot ballot = *cast(SCPBallot*)&cur;

            // only consider it if we can potentially raise h
            if (mHighBallot && compareBallots(*mHighBallot, ballot) >= 0)
                break;

            bool ratified = federatedRatify(
                (ref const(SCPStatement) st) => hasPreparedBallot(ballot, st));
            if (ratified)
            {
                newH = ballot;
                newHfound = true;
                break;
            }
        }

        if (!newHfound)
            return false;

        SCPBallot newC;
        // now, look for newC (left as 0 if no update)
        // step (3) from the paper
        SCPBallot b = mCurrentBallot ? *mCurrentBallot : SCPBallot();
        if (!mCommit &&
            (!mPrepared || !areBallotsLessAndIncompatible(newH, *mPrepared)) &&
            (!mPreparedPrime ||
             !areBallotsLessAndIncompatible(newH, *mPreparedPrime)))
        {
            // continue where we left off (cur is at newH at this point)
            foreach (cur; range)
            {
                SCPBallot ballot = *cast(SCPBallot*)&cur;
                if (compareBallots(ballot, b) < 0)
                    break;

                // c and h must be compatible
                if (!areBallotsLessAndCompatible(cur, newH))
                    continue;

                bool ratified = federatedRatify(
                    (ref const(SCPStatement) st) => hasPreparedBallot(ballot, st));
                if (ratified)
                    newC = ballot;
                else
                    break;
            }
        }

        return this.setPreparedConfirmed(newC, newH);
    }

    // newC, newH : low/high bounds prepared confirmed
    private bool setPreparedConfirmed(ref const(SCPBallot) newC, ref const(SCPBallot) newH)
    {
        //if (Logging.logTrace("SCP"))
        //    log.trace("BallotProtocol.setPreparedConfirmed"
        //                       << " i: " << mSlot.getSlotIndex()
        //                       << " h: " << mSlot.getSCP().ballotToStr(newH);

        bool didWork = false;

        // remember newH's value
        mValueOverride = newH.value.dup;

        // we don't set c/h if we're not on a compatible ballot
        if (!mCurrentBallot || areBallotsCompatible(*mCurrentBallot, newH))
        {
            if (!mHighBallot || compareBallots(newH, *mHighBallot) > 0)
            {
                didWork = true;
                mHighBallot = new SCPBallot;
                *mHighBallot = *cast(SCPBallot*)&newH;
            }

            if (newC.counter != 0)
            {
                assert(!mCommit);
                mCommit = new SCPBallot;
                *mCommit = *cast(SCPBallot*)&newC;
                didWork = true;
            }

            if (didWork)
            {
                mSlot.getSCPDriver().confirmedBallotPrepared(mSlot.getSlotIndex(),
                                                             newH);
            }
        }

        // always perform step (8) with the computed value of h
        didWork = updateCurrentIfNeeded(newH) || didWork;

        if (didWork)
            this.emitCurrentStateStatement();

        return didWork;
    }

    // step (4 and 6)+8 from the SCP paper
    private bool attemptAcceptCommit(ref const(SCPStatement) hint)
    {
        if (mPhase != SCPPhase.SCP_PHASE_PREPARE && mPhase != SCPPhase.SCP_PHASE_CONFIRM)
        {
            return false;
        }

        // extracts value from hint
        // note: ballot.counter is only used for logging purpose as we're looking at
        // possible value to commit
        SCPBallot ballot;
        switch (hint.pledges.type)
        {
            case SCPStatementType.SCP_ST_PREPARE:
            {
                const prep = &hint.pledges.prepare_;
                if (prep.nC != 0)
                {
                    ballot = SCPBallot(prep.nH, prep.ballot.value.dup);
                }
                else
                {
                    return false;
                }
            }
            break;

            case SCPStatementType.SCP_ST_CONFIRM:
            {
                const con = &hint.pledges.confirm_;
                ballot = SCPBallot(con.nH, con.ballot.value.dup);
            }
            break;

            case SCPStatementType.SCP_ST_EXTERNALIZE:
            {
                const ext = &hint.pledges.externalize_;
                ballot = SCPBallot(ext.nH, ext.commit.value.dup);
                break;
            }

            default:
                assert(0);
        }

        if (mPhase == SCPPhase.SCP_PHASE_CONFIRM)
        {
            if (!areBallotsCompatible(ballot, *mHighBallot))
            {
                return false;
            }
        }

        auto pred = (ref const(Interval) cur) {
            return federatedAccept(
                (ref const(SCPStatement) st) {
                    bool res = false;
                    const pl = &st.pledges;
                    switch (pl.type)
                    {
                    case SCPStatementType.SCP_ST_PREPARE:
                    {
                        const p = &pl.prepare_;
                        if (areBallotsCompatible(ballot, p.ballot))
                        {
                            if (p.nC != 0)
                            {
                                res = p.nC <= cur.first && cur.second <= p.nH;
                            }
                        }
                    }
                    break;
                    case SCPStatementType.SCP_ST_CONFIRM:
                    {
                        const c = &pl.confirm_;
                        if (areBallotsCompatible(ballot, c.ballot))
                        {
                            res = c.nCommit <= cur.first;
                        }
                    }
                    break;
                    case SCPStatementType.SCP_ST_EXTERNALIZE:
                    {
                        const e = &pl.externalize_;
                        if (areBallotsCompatible(ballot, e.commit))
                        {
                            res = e.commit.counter <= cur.first;
                        }
                    }
                    break;
                    default:
                        assert(0);
                    }
                    return res;
                },

                (ref const(SCPStatement) st) => commitPredicate(ballot, cur, st));
        };

        // build the boundaries to scan
        set!uint32 boundaries = getCommitBoundariesFromStatements(ballot);

        if (boundaries.empty())
        {
            return false;
        }

        // now, look for the high interval
        Interval candidate;

        findExtendedInterval(candidate, boundaries, pred);

        bool res = false;

        if (candidate.first != 0)
        {
            if (mPhase != SCPPhase.SCP_PHASE_CONFIRM ||
                candidate.second > mHighBallot.counter)
            {
                SCPBallot c = SCPBallot(candidate.first, ballot.value);
                SCPBallot h = SCPBallot(candidate.second, ballot.value);
                res = setAcceptCommit(c, h);
            }
        }

        return res;
    }

    // new values for c and h
    private bool setAcceptCommit(ref const(SCPBallot) c, ref const(SCPBallot) h)
    {
        //if (Logging.logTrace("SCP"))
        //    log.trace("BallotProtocol.setAcceptCommit"
        //                       << " i: " << mSlot.getSlotIndex()
        //                       << " new c: " << mSlot.getSCP().ballotToStr(c)
        //                       << " new h: " << mSlot.getSCP().ballotToStr(h);

        bool didWork = false;

        // remember h's value
        mValueOverride = h.value.dup;

        if (!mHighBallot || !mCommit || compareBallots(*mHighBallot, h) != 0 ||
            compareBallots(*mCommit, c) != 0)
        {
            mCommit = new SCPBallot;
            *mCommit = *cast(SCPBallot*)&c;
            mHighBallot = new SCPBallot;
            *mHighBallot = *cast(SCPBallot*)&h;

            didWork = true;
        }

        if (mPhase == SCPPhase.SCP_PHASE_PREPARE)
        {
            mPhase = SCPPhase.SCP_PHASE_CONFIRM;
            if (mCurrentBallot && !areBallotsLessAndCompatible(h, *mCurrentBallot))
            {
                bumpToBallot(h, false);
            }
            mPreparedPrime = null;

            didWork = true;
        }

        if (didWork)
        {
            updateCurrentIfNeeded(*mHighBallot);

            mSlot.getSCPDriver().acceptedCommit(mSlot.getSlotIndex(), h);
            this.emitCurrentStateStatement();
        }

        return didWork;
    }

    private static uint32 statementBallotCounter (ref const(SCPStatement) st)
    {
        switch (st.pledges.type)
        {
        case SCPStatementType.SCP_ST_PREPARE:
            return st.pledges.prepare_.ballot.counter;
        case SCPStatementType.SCP_ST_CONFIRM:
            return st.pledges.confirm_.ballot.counter;
        case SCPStatementType.SCP_ST_EXTERNALIZE:
            return uint.max;
        default:
            // Should never be called with SCPStatementType.SCP_ST_NOMINATE.
            assert(0);
        }
    }

    private static bool hasVBlockingSubsetStrictlyAheadOf (
        LocalNode localNode, const(SCPEnvelope[NodeID]) map, uint32_t n)
    {
        return LocalNode.isVBlocking(
            localNode.getQuorumSet(), map,
            (ref const(SCPStatement) st) { return statementBallotCounter(st) > n; });
    }

    // step 7+8 from the SCP paper
    private bool attemptConfirmCommit (ref const(SCPStatement) hint)
    {
        if (mPhase != SCPPhase.SCP_PHASE_CONFIRM)
        {
            return false;
        }

        if (!mHighBallot || !mCommit)
        {
            return false;
        }

        // extracts value from hint
        // note: ballot.counter is only used for logging purpose
        SCPBallot ballot;
        switch (hint.pledges.type)
        {
            case SCPStatementType.SCP_ST_PREPARE:
            {
                return false;
            }
            break;
            case SCPStatementType.SCP_ST_CONFIRM:
            {
                const con = &hint.pledges.confirm_;
                ballot = SCPBallot(con.nH, con.ballot.value.dup);
            }
            break;
            case SCPStatementType.SCP_ST_EXTERNALIZE:
            {
                const ext = &hint.pledges.externalize_;
                ballot = SCPBallot(ext.nH, ext.commit.value.dup);
                break;
            }
            default:
                assert(0);
        }

        if (!areBallotsCompatible(ballot, *mCommit))
        {
            return false;
        }

        set!uint32 boundaries = getCommitBoundariesFromStatements(ballot);
        Interval candidate;

        auto pred = (ref const(Interval) cur) {
            return federatedRatify(
                (ref const(SCPStatement) st) => commitPredicate(ballot, cur, st));
        };

        findExtendedInterval(candidate, boundaries, pred);

        bool res = candidate.first != 0;
        if (res)
        {
            SCPBallot c = SCPBallot(candidate.first, ballot.value);
            SCPBallot h = SCPBallot(candidate.second, ballot.value);
            return setConfirmCommit(c, h);
        }
        return res;
    }

    private bool setConfirmCommit (ref const(SCPBallot) c,
        ref const(SCPBallot) h)
    {
        //if (Logging.logTrace("SCP"))
        //    log.trace("BallotProtocol.setConfirmCommit"
        //                       << " i: " << mSlot.getSlotIndex()
        //                       << " new c: " << mSlot.getSCP().ballotToStr(c)
        //                       << " new h: " << mSlot.getSCP().ballotToStr(h);

        mCommit = new SCPBallot;
        *mCommit = *cast(SCPBallot*)&c;
        mHighBallot = new SCPBallot;
        *mHighBallot = *cast(SCPBallot*)&h;
        updateCurrentIfNeeded(*mHighBallot);

        mPhase = SCPPhase.SCP_PHASE_EXTERNALIZE;

        this.emitCurrentStateStatement();

        mSlot.stopNomination();

        mSlot.getSCPDriver().valueExternalized(mSlot.getSlotIndex(),
                                               mCommit.value);

        return true;
    }

    // Step 9 from the paper (Feb 2016):
    //
    //   If ∃ S ⊆ M such that the set of senders {v_m | m ∈ S} is v-blocking
    //   and ∀m ∈ S, b_m.n > b_v.n, then set b <- <n, z> where n is the lowest
    //   counter for which no such S exists.
    //
    // a.k.a 4th rule for setting ballot.counter in the internet-draft (v03):
    //
    //   If nodes forming a blocking threshold all have ballot.counter values
    //   greater than the local ballot.counter, then the local node immediately
    //   cancels any pending timer, increases ballot.counter to the lowest
    //   value such that this is no longer the case, and if appropriate
    //   according to the rules above arms a new timer. Note that the blocking
    //   threshold may include ballots from SCPCommit messages as well as
    //   SCPExternalize messages, which implicitly have an infinite ballot
    //   counter.

    private bool attemptBump ()
    {
        if (mPhase == SCPPhase.SCP_PHASE_PREPARE || mPhase == SCPPhase.SCP_PHASE_CONFIRM)
        {

            // First check to see if this condition applies at all. If there
            // is no v-blocking set ahead of the local node, there's nothing
            // to do, return early.
            auto localNode = getLocalNode();
            uint32 localCounter = mCurrentBallot ? mCurrentBallot.counter : 0;
            if (!hasVBlockingSubsetStrictlyAheadOf(localNode, mLatestEnvelopes,
                                                   localCounter))
            {
                return false;
            }

            // Collect all possible counters we might need to advance to.
            set!uint32 allCounters;
            foreach (node_id, e; mLatestEnvelopes)
            {
                uint32_t c = statementBallotCounter(e.statement);
                if (c > localCounter)
                    allCounters.insert(c);
            }

            // If we got to here, implicitly there _was_ a v-blocking subset
            // with counters above the local counter; we just need to find a
            // minimal n at which that's no longer true. So check them in
            // order, starting from the smallest.
            foreach (uint32_t n; allCounters)
            {
                if (!hasVBlockingSubsetStrictlyAheadOf(localNode, mLatestEnvelopes,
                                                       n))
                {
                    // Move to n.
                    return this.abandonBallot(n);
                }
            }
        }
        return false;
    }

    // computes a list of candidate values that may have been prepared
    private set!SCPBallot getPrepareCandidates(ref const(SCPStatement) hint)
    {
        set!SCPBallot hintBallots;

        switch (hint.pledges.type)
        {
            case SCPStatementType.SCP_ST_PREPARE:
            {
                const prep = &hint.pledges.prepare_;
                hintBallots.insert(prep.ballot);
                if (prep.prepared)
                {
                    hintBallots.insert(*prep.prepared);
                }
                if (prep.preparedPrime)
                {
                    hintBallots.insert(*prep.preparedPrime);
                }
            }
            break;
            case SCPStatementType.SCP_ST_CONFIRM:
            {
                const con = &hint.pledges.confirm_;
                hintBallots.insert(SCPBallot(con.nPrepared, con.ballot.value.dup));
                hintBallots.insert(SCPBallot(uint.max, con.ballot.value.dup));
            }
            break;
            case SCPStatementType.SCP_ST_EXTERNALIZE:
            {
                const ext = &hint.pledges.externalize_;
                hintBallots.insert(SCPBallot(uint.max, ext.commit.value.dup));
            }
            break;
            default:
                assert(0);
        }

        set!SCPBallot candidates;

        while (!hintBallots.length != 0)
        {
            const(SCPBallot) topVote = hintBallots[].front;
            hintBallots.removeFront();

            const val = &topVote.value;

            // find candidates that may have been prepared
            foreach (node_id, env; mLatestEnvelopes)
            {
                const(SCPStatement)* st = &env.statement;
                switch (st.pledges.type)
                {
                case SCPStatementType.SCP_ST_PREPARE:
                {
                    const prep = &st.pledges.prepare_;
                    if (areBallotsLessAndCompatible(prep.ballot, topVote))
                    {
                        candidates.insert(prep.ballot);
                    }
                    if (prep.prepared &&
                        areBallotsLessAndCompatible(*prep.prepared, topVote))
                    {
                        candidates.insert(*prep.prepared);
                    }
                    if (prep.preparedPrime &&
                        areBallotsLessAndCompatible(*prep.preparedPrime, topVote))
                    {
                        candidates.insert(*prep.preparedPrime);
                    }
                }
                break;
                case SCPStatementType.SCP_ST_CONFIRM:
                {
                    const con = &st.pledges.confirm_;
                    if (areBallotsCompatible(topVote, con.ballot))
                    {
                        candidates.insert(topVote);
                        if (con.nPrepared < topVote.counter)
                        {
                            candidates.insert(SCPBallot(con.nPrepared, (*val).dup));
                        }
                    }
                }
                break;
                case SCPStatementType.SCP_ST_EXTERNALIZE:
                {
                    const ext = &st.pledges.externalize_;
                    if (areBallotsCompatible(topVote, ext.commit))
                    {
                        candidates.insert(topVote);
                    }
                }
                break;
                default:
                    assert(0);
                }
            }
        }

        return candidates;
    }

    // helper to perform step (8) from the paper
    private bool updateCurrentIfNeeded(ref const(SCPBallot) h)
    {
        bool didWork = false;
        if (!mCurrentBallot || compareBallots(*mCurrentBallot, h) < 0)
        {
            bumpToBallot(h, true);
            didWork = true;
        }
        return didWork;
    }

    // helper function to find a contiguous range 'candidate' that satisfies the
    // predicate.
    // updates 'candidate' (or leave it unchanged)
    private static void findExtendedInterval (
        ref Interval candidate, ref const(set!uint32) boundaries,
        bool delegate(ref const(Interval)) pred)
    {
        // iterate through interesting boundaries, starting from the top
        foreach (it; boundaries[].retro)
        {
            uint32 b = it;

            Interval cur;
            if (candidate.first == 0)
            {
                // first, find the high bound
                cur = Interval(b, b);
            }
            else if (b > candidate.second) // invalid
            {
                continue;
            }
            else
            {
                cur.first = b;
                cur.second = candidate.second;
            }

            if (pred(cur))
            {
                candidate = cur;
            }
            else if (candidate.first != 0)
            {
                // could not extend further
                break;
            }
        }
    }

    // constructs the set of counters representing the
    // commit ballots compatible with the ballot
    private set!uint32 getCommitBoundariesFromStatements (
        ref const(SCPBallot) ballot)
    {
        set!uint32 res;
        foreach (node_id, env; mLatestEnvelopes)
        {
            const pl = &env.statement.pledges;
            switch (pl.type)
            {
            case SCPStatementType.SCP_ST_PREPARE:
            {
                const p = &pl.prepare_;
                if (areBallotsCompatible(ballot, p.ballot))
                {
                    if (p.nC)
                    {
                        res.insert(p.nC);
                        res.insert(p.nH);
                    }
                }
            }
            break;
            case SCPStatementType.SCP_ST_CONFIRM:
            {
                const c = &pl.confirm_;
                if (areBallotsCompatible(ballot, c.ballot))
                {
                    res.insert(c.nCommit);
                    res.insert(c.nH);
                }
            }
            break;
            case SCPStatementType.SCP_ST_EXTERNALIZE:
            {
                const e = &pl.externalize_;
                if (areBallotsCompatible(ballot, e.commit))
                {
                    res.insert(e.commit.counter);
                    res.insert(e.nH);
                    res.insert(uint.max);
                }
            }
            break;
            default:
                assert(0);
            }
        }
        return res;
    }

    // ** helper predicates that evaluate if a statement satisfies
    // a certain property

    // is ballot prepared by st
    private static bool hasPreparedBallot (ref const(SCPBallot) ballot,
        ref const(SCPStatement) st)
    {
        bool res;

        final switch (st.pledges.type)
        {
            case SCPStatementType.SCP_ST_PREPARE:
            {
                const p = &st.pledges.prepare_;
                res =
                    (p.prepared && areBallotsLessAndCompatible(ballot, *p.prepared)) ||
                    (p.preparedPrime &&
                     areBallotsLessAndCompatible(ballot, *p.preparedPrime));
                break;
            }

            case SCPStatementType.SCP_ST_CONFIRM:
            {
                const c = &st.pledges.confirm_;
                SCPBallot prepared = SCPBallot(c.nPrepared, c.ballot.value.dup);
                res = areBallotsLessAndCompatible(ballot, prepared);
                break;
            }

            case SCPStatementType.SCP_ST_EXTERNALIZE:
            {
                const e = &st.pledges.externalize_;
                res = areBallotsCompatible(ballot, e.commit);
                break;
            }

            case SCPStatementType.SCP_ST_NOMINATE:
                assert(0);
        }

        return res;
    }

    // returns true if the statement commits the ballot in the range 'check'
    private static bool commitPredicate (ref const(SCPBallot) ballot,
        ref const(Interval) check, ref const(SCPStatement) st)
    {
        bool res = false;
        const pl = &st.pledges;
        switch (pl.type)
        {
        case SCPStatementType.SCP_ST_PREPARE:
            break;
        case SCPStatementType.SCP_ST_CONFIRM:
        {
            const c = &pl.confirm_;
            if (areBallotsCompatible(ballot, c.ballot))
            {
                res = c.nCommit <= check.first && check.second <= c.nH;
            }
        }
        break;
        case SCPStatementType.SCP_ST_EXTERNALIZE:
        {
            const e = &pl.externalize_;
            if (areBallotsCompatible(ballot, e.commit))
            {
                res = e.commit.counter <= check.first;
            }
        }
        break;
        default:
            assert(0);
        }
        return res;
    }

    // attempts to update p to ballot (updating p' if needed)
    private bool setPrepared (ref const(SCPBallot) ballot)
    {
        bool didWork = false;

        // p and p' are the two higest prepared and incompatible ballots
        if (mPrepared)
        {
            int comp = compareBallots(*mPrepared, ballot);
            if (comp < 0)
            {
                // as we're replacing p, we see if we should also replace p'
                if (!areBallotsCompatible(*mPrepared, ballot))
                {
                    mPreparedPrime = new SCPBallot;
                    *mPreparedPrime = *mPrepared;
                }
                mPrepared = new SCPBallot;
                *mPrepared = *cast(SCPBallot*)&ballot;
                didWork = true;
            }
            else if (comp > 0)
            {
                // check if we should update only p', this happens
                // either p' was null
                // or p' gets replaced by ballot
                //      (p' < ballot and ballot is incompatible with p)
                // note, the later check is here out of paranoia as this function is
                // not called with a value that would not allow us to make progress

                if (!mPreparedPrime ||
                    ((compareBallots(*mPreparedPrime, ballot) < 0) &&
                     !areBallotsCompatible(*mPrepared, ballot)))
                {
                    mPreparedPrime = new SCPBallot;
                    *mPreparedPrime = *cast(SCPBallot*)&ballot;
                    didWork = true;
                }
            }
        }
        else
        {
            mPrepared = new SCPBallot;
            *mPrepared = *cast(SCPBallot*)&ballot;
            didWork = true;
        }
        return didWork;
    }

    // ** Helper methods to compare two ballots

    // ballot comparison (ordering)
    private static int compareBallots (ref const(SCPBallot*) b1,
        ref const(SCPBallot*) b2)
    {
        int res;
        if (b1 && b2)
        {
            res = compareBallots(*b1, *b2);
        }
        else if (b1 && !b2)
        {
            res = 1;
        }
        else if (!b1 && b2)
        {
            res = -1;
        }
        else
        {
            res = 0;
        }
        return res;
    }

    private static int compareBallots (ref const(SCPBallot) b1,
        ref const(SCPBallot) b2)
    {
        if (b1.counter < b2.counter)
            return -1;
        else if (b2.counter < b1.counter)
            return 1;

        // ballots are also strictly ordered by value
        if (b1.value < b2.value)
            return -1;
        else if (b2.value < b1.value)
            return 1;
        else
            return 0;
    }

    // b1 ~ b2
    private static bool areBallotsCompatible (ref const(SCPBallot) b1,
        ref const(SCPBallot) b2)
    {
        return b1.value == b2.value;
    }

    // b1 <= b2 && b1 !~ b2
    private static bool areBallotsLessAndIncompatible (ref const(SCPBallot) b1,
        ref const(SCPBallot) b2)
    {
        return (compareBallots(b1, b2) <= 0) && !areBallotsCompatible(b1, b2);
    }

    // b1 <= b2 && b1 ~ b2
    private static bool areBallotsLessAndCompatible (ref const(SCPBallot) b1,
        ref const(SCPBallot) b2)
    {
        return (compareBallots(b1, b2) <= 0) && areBallotsCompatible(b1, b2);
    }

    // ** statement helper functions

    // returns true if the statement is newer than the one we know about
    // for a given node.
    private bool isNewerStatement (ref const(NodeID) nodeID,
        ref const(SCPStatement) st)
    {
        if (auto oldp = nodeID in mLatestEnvelopes)
            return isNewerStatement(oldp.statement, st);

        return false;
    }

    // returns true if new_st is newer than old_st
    private static bool isNewerStatement (ref const(SCPStatement) old_st,
        ref const(SCPStatement) new_st)
    {
        // total ordering described in SCP paper.
        const st_type = new_st.pledges.type;

        // if different type, must be (PREPARE < CONFIRM < EXTERNALIZE)
        if (old_st.pledges.type != st_type)
            return old_st.pledges.type < st_type;

        // can't have duplicate EXTERNALIZE statements
        if (st_type == SCPStatementType.SCP_ST_EXTERNALIZE)
            return false;

        if (st_type == SCPStatementType.SCP_ST_CONFIRM)
        {
            // sorted by (b, p, p', h) (p' = 0 implicitely)
            const oldC = &old_st.pledges.confirm_;
            const c = &new_st.pledges.confirm_;
            int compBallot = compareBallots(oldC.ballot, c.ballot);
            if (compBallot < 0)
                return true;  // oldC is older

            if (compBallot > 0)
                return false;  // oldC is newer

            assert(compBallot == 0);
            if (oldC.nPrepared == c.nPrepared)
                return oldC.nH < c.nH;
            else
                return oldC.nPrepared < c.nPrepared;
        }
        else
        {
            assert(st_type == SCPStatementType.SCP_ST_PREPARE);

            // Lexicographical order between PREPARE statements:
            // (b, p, p', h)
            const oldPrep = &old_st.pledges.prepare_;
            const prep = &new_st.pledges.prepare_;

            int compBallot = compareBallots(oldPrep.ballot, prep.ballot);
            if (compBallot < 0)
                return true;  // oldPrep ballot is older

            if (compBallot > 0)
                return false;  // oldPrep ballot is newer

            assert(compBallot == 0);

            compBallot = compareBallots(oldPrep.prepared, prep.prepared);
            if (compBallot < 0)  // oldPrep prepared is older
                return true;

            if (compBallot > 0)  // oldPrep prepared is newer
                return false;

            assert(compBallot == 0);
            compBallot = compareBallots(oldPrep.preparedPrime,
                                        prep.preparedPrime);
            if (compBallot < 0)
                return true;  // oldPrep.preparedPrime is older

            if (compBallot > 0)
                return false;  // oldPrep.preparedPrime is newer

            assert(compBallot == 0);
            return oldPrep.nH < prep.nH;
        }
    }

    // basic sanity check on statement
    private bool isStatementSane (ref const(SCPStatement) st, bool self)
    {
        const NoExtraChecks = false;
        const(char)* reason = null;
        auto qSet = mSlot.getQuorumSetFromStatement(st);
        if (!qSet.ok || !isQuorumSetSane(qSet, NoExtraChecks, &reason))
        {
            // todo: use 'reason'
            log.info("Invalid quorum set received");
            return false;
        }

        final switch (st.pledges.type)
        {
            case SCPStatementType.SCP_ST_PREPARE:
            {
                const p = &st.pledges.prepare_;
                // self is allowed to have b = 0 (as long as it never gets emitted)
                bool isOK = self || p.ballot.counter > 0;

                isOK = isOK &&
                       (!p.preparedPrime || !p.prepared ||
                        (areBallotsLessAndIncompatible(*p.preparedPrime, *p.prepared)));

                isOK =
                    isOK && (p.nH == 0 || (p.prepared && p.nH <= p.prepared.counter));

                // c != 0 . c <= h <= b
                isOK = isOK && (p.nC == 0 || (p.nH != 0 && p.ballot.counter >= p.nH &&
                                              p.nH >= p.nC));

                if (!isOK)
                    log.trace("Malformed PREPARE message");

                return isOK;
            }

            case SCPStatementType.SCP_ST_CONFIRM:
            {
                const c = &st.pledges.confirm_;
                // c <= h <= b
                bool isOK = c.ballot.counter > 0;
                isOK = isOK && (c.nH <= c.ballot.counter);
                isOK = isOK && (c.nCommit <= c.nH);
                if (!isOK)
                    log.trace("Malformed CONFIRM message");
                return isOK;
            }

            case SCPStatementType.SCP_ST_EXTERNALIZE:
            {
                const e = &st.pledges.externalize_;

                bool isOK = e.commit.counter > 0;
                isOK = isOK && e.nH >= e.commit.counter;

                if (!isOK)
                    log.trace("Malformed EXTERNALIZE message");

                return isOK;
            }

            case SCPStatementType.SCP_ST_NOMINATE:
                assert(0);
        }
    }

    // stores the statement in the state machine, it doesn't trigger
    // any state changes alone however
    private void recordEnvelope (ref const(SCPEnvelope) env)
    {
        const st = &env.statement;
        mLatestEnvelopes[st.nodeID] = env;
        mSlot.recordStatement(env.statement);
    }

    // ** State related methods

    // helper function that updates the current ballot
    // this is the lowest level method to update the current ballot and as
    // such doesn't do any validation
    // check: verifies that ballot is greater than old one
    private void bumpToBallot (ref const(SCPBallot) ballot, bool check)
    {
        //if (Logging.logTrace("SCP"))
        //    log.trace("BallotProtocol.bumpToBallot"
        //                       << " i: " << mSlot.getSlotIndex()
        //                       << " b: " << mSlot.getSCP().ballotToStr(ballot);

        // `bumpToBallot` should be never called once we committed.
        assert(mPhase != SCPPhase.SCP_PHASE_EXTERNALIZE);

        if (check)
        {
            // We should move mCurrentBallot monotonically only
            assert(!mCurrentBallot ||
                      compareBallots(ballot, *mCurrentBallot) >= 0);
        }

        bool gotBumped =
            !mCurrentBallot || (mCurrentBallot.counter != ballot.counter);

        if (!mCurrentBallot)
        {
            mSlot.getSCPDriver().startedBallotProtocol(mSlot.getSlotIndex(),
                                                       ballot);
        }

        mCurrentBallot = new SCPBallot;
        *mCurrentBallot = cast(SCPBallot)ballot;

        // invariant: h.value = b.value
        if (mHighBallot !is null &&
            !areBallotsCompatible(*mCurrentBallot, *mHighBallot))
            mHighBallot = null;

        if (gotBumped)
            mHeardFromQuorum = false;
    }

    // switch the local node to the given ballot's value
    // with the assumption that the ballot is more recent than the one
    // we have.
    // updates the local state based to the specified ballot
    // (that could be a prepared ballot) enforcing invariants
    private bool updateCurrentValue (ref const(SCPBallot) ballot)
    {
        if (mPhase != SCPPhase.SCP_PHASE_PREPARE &&
            mPhase != SCPPhase.SCP_PHASE_CONFIRM)
            return false;

        bool updated = false;
        if (!mCurrentBallot)
        {
            bumpToBallot(ballot, true);
            updated = true;
        }
        else
        {
            assert(compareBallots(*mCurrentBallot, ballot) <= 0);

            if (mCommit && !areBallotsCompatible(*mCommit, ballot))
            {
                return false;
            }

            int comp = compareBallots(*mCurrentBallot, ballot);
            if (comp < 0)
            {
                bumpToBallot(ballot, true);
                updated = true;
            }
            else if (comp > 0)
            {
                // this code probably changes with the final version
                // of the conciliator

                // this case may happen if the other nodes are not
                // following the protocol (and we end up with a smaller value)
                // not sure what is the best way to deal
                // with this situation
                //CLOG(ERROR, "SCP")
                //    << "BallotProtocol.updateCurrentValue attempt to bump to "
                //       "a smaller value";
                // can't just bump to the value as we may already have
                // statements at counter+1
                return false;
            }
        }

        //if (updated)
            //log.trace("BallotProtocol.updateCurrentValue updated";

        checkInvariants();

        return updated;
    }

    // emits a statement reflecting the nodes' current state
    // and attempts to make progress
    private void emitCurrentStateStatement ()
    {
        SCPStatementType t;

        final switch (mPhase)
        {
            case SCPPhase.SCP_PHASE_PREPARE:
                t = SCPStatementType.SCP_ST_PREPARE;
                break;

            case SCPPhase.SCP_PHASE_CONFIRM:
                t = SCPStatementType.SCP_ST_CONFIRM;
                break;

            case SCPPhase.SCP_PHASE_EXTERNALIZE:
                t = SCPStatementType.SCP_ST_EXTERNALIZE;
                break;
        }

        SCPStatement statement = createStatement(t);
        SCPEnvelope envelope = mSlot.createEnvelope(statement);

        bool canEmit = (mCurrentBallot !is null);

        // if we generate the same envelope, don't process it again
        // this can occur when updating h in PREPARE phase
        // as statements only keep track of h.n (but h.x could be different)
        auto lastEnv = mSlot.getSCP().getLocalNodeID() in mLatestEnvelopes;

        if (lastEnv is null || *lastEnv != envelope)
        {
            const FromSelf = true;
            if (mSlot.processEnvelope(envelope, FromSelf) !=
                SCP.EnvelopeState.VALID)
                assert(0, "moved to a bad state (ballot protocol)");

            if (canEmit &&
                (!mLastEnvelope || isNewerStatement(mLastEnvelope.statement,
                                                    envelope.statement)))
            {
                mLastEnvelope = new SCPEnvelope;
                *mLastEnvelope = envelope;
                // this will no-op if invoked from advanceSlot
                // as advanceSlot consolidates all messages sent
                sendLatestEnvelope();
            }
        }
    }

    // verifies that the internal state is consistent
    private void checkInvariants()
    {
        if (mCurrentBallot)
            assert(mCurrentBallot.counter != 0);

        if (mPrepared && mPreparedPrime)
            assert(areBallotsLessAndIncompatible(*mPreparedPrime, *mPrepared));

        if (mHighBallot)
        {
            assert(mCurrentBallot);
            assert(areBallotsLessAndCompatible(*mHighBallot, *mCurrentBallot));
        }

        if (mCommit)
        {
            assert(mCurrentBallot);
            assert(areBallotsLessAndCompatible(*mCommit, *mHighBallot));
            assert(areBallotsLessAndCompatible(*mHighBallot, *mCurrentBallot));
        }

        final switch (mPhase)
        {
            case SCPPhase.SCP_PHASE_PREPARE:
                break;

            case SCPPhase.SCP_PHASE_CONFIRM:
                assert(mCommit);
                break;

            case SCPPhase.SCP_PHASE_EXTERNALIZE:
                assert(mCommit);
                assert(mHighBallot);
                break;
        }
    }

    // create a statement of the given type using the local state
    SCPStatement createStatement (ref const(SCPStatementType) type)
    {
        SCPStatement statement;

        checkInvariants();

        statement.pledges.type = type;

        final switch (type)
        {
            case SCPStatementType.SCP_ST_PREPARE:
            {
                auto p = &statement.pledges.prepare_;
                p.quorumSetHash = getLocalNode().getQuorumSetHash();
                if (mCurrentBallot)
                    p.ballot = *mCurrentBallot;

                if (mCommit)
                    p.nC = mCommit.counter;

                if (mPrepared)
                    p.prepared = new SCPBallot;
                    *p.prepared = *mPrepared;

                if (mPreparedPrime)
                    p.preparedPrime = new SCPBallot;
                    *p.preparedPrime = *mPreparedPrime;

                if (mHighBallot)
                    p.nH = mHighBallot.counter;

                break;
            }

            case SCPStatementType.SCP_ST_CONFIRM:
            {
                auto c = &statement.pledges.confirm_;
                c.quorumSetHash = getLocalNode().getQuorumSetHash();
                c.ballot = *mCurrentBallot;
                c.nPrepared = mPrepared.counter;
                c.nCommit = mCommit.counter;
                c.nH = mHighBallot.counter;
                break;
            }

            case SCPStatementType.SCP_ST_EXTERNALIZE:
            {
                auto e = &statement.pledges.externalize_;
                e.commit = *mCommit;
                e.nH = mHighBallot.counter;
                e.commitQuorumSetHash = getLocalNode().getQuorumSetHash();
                break;
            }

            case SCPStatementType.SCP_ST_NOMINATE:
                assert(0);
        }

        return statement;
    }

    private LocalNode getLocalNode ()
    {
        return mSlot.getSCP().getLocalNode();
    }

    private bool federatedAccept (StatementPredicate voted,
        StatementPredicate accepted)
    {
        return mSlot.federatedAccept(voted, accepted, mLatestEnvelopes);
    }

    private bool federatedRatify (StatementPredicate voted)
    {
        return mSlot.federatedRatify(voted, mLatestEnvelopes);
    }

    private void startBallotProtocolTimer ()
    {
        Duration timeout =
            mSlot.getSCPDriver().computeTimeout(mCurrentBallot.counter);

        mSlot.getSCPDriver().setupTimer(
            mSlot.getSlotIndex(), TimerID.BALLOT_PROTOCOL_TIMER, timeout,
            &mSlot.getBallotProtocol().ballotProtocolTimerExpired);
    }

    private void stopBallotProtocolTimer ()
    {
        mSlot.getSCPDriver().setupTimer(mSlot.getSlotIndex(),
                                        TimerID.BALLOT_PROTOCOL_TIMER,
                                        0.seconds, null);
    }

    private void checkHeardFromQuorum ()
    {
        // this method is safe to call regardless of the transitions of the other
        // nodes on the network:
        // we guarantee that other nodes can only transition to higher counters
        // (messages are ignored upstream)
        // therefore the local node will not flip flop between "seen" and "not seen"
        // for a given counter on the local node

        if (mCurrentBallot is null)
            return;

        if (LocalNode.isQuorum(
                getLocalNode().getQuorumSet(), mLatestEnvelopes,
                &mSlot.getQuorumSetFromStatement,
                (ref const(SCPStatement) st) {
                    bool res;
                    if (st.pledges.type == SCPStatementType.SCP_ST_PREPARE)
                    {
                        res = mCurrentBallot.counter <=
                              st.pledges.prepare_.ballot.counter;
                    }
                    else
                    {
                        res = true;
                    }
                    return res;
                }))
        {
            bool oldHQ = mHeardFromQuorum;
            mHeardFromQuorum = true;
            if (!oldHQ)
            {
                // if we transition from not heard . heard, we start the timer
                mSlot.getSCPDriver().ballotDidHearFromQuorum(
                    mSlot.getSlotIndex(), *mCurrentBallot);
                if (mPhase != SCPPhase.SCP_PHASE_EXTERNALIZE)
                {
                    startBallotProtocolTimer();
                }
            }
            if (mPhase == SCPPhase.SCP_PHASE_EXTERNALIZE)
            {
                stopBallotProtocolTimer();
            }
        }
        else
        {
            mHeardFromQuorum = false;
            stopBallotProtocolTimer();
        }
    }
}
